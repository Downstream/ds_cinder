#include "model_maker.h"

#include <map>
#include <sstream>
#include <fstream>
#include <iostream>

#include <ds/math/random.h>
#include <ds/app/environment.h>
#include <ds/debug/logger.h>
#include <ds/query/query_client.h>
#include <ds/util/string_util.h>


namespace ds {

namespace {

const std::string baseHeader = \
"#pragma once\n#ifndef DS_MODEL_AUTOGENERATED_TableName\n"\
"#define DS_MODEL_AUTOGENERATED_TableName" \
"\n\n#include <ds/data/resource.h>\n#include <memory>\n#include <vector>\n#include <cinder/Vector.h>" \
"\n\n" \
"namespace ds {\n" \
"namespace model{\n" \
"/**\n" \
"* \\class ds::model::TableNameRef\n" \
"*			Auto-generated data model for TableName\n" \
"*/\n" \
"class TableNameRef {\n" \
"public:\n" \
"\n" \
"	TableNameRef();\n" \
"\n"
"COLUMN_GETTERS\n" \
"\n" \
"COLUMN_SETTERS\n" \
"\n" \
"\n" \
"private:\n" \
"	class Data;\n" \
"	std::shared_ptr<Data>	mData;\n" \
"};\n" \
"\n" \
"} // namespace model\n" \
"} // namespace ds\n" \
"\n" \
"#endif\n";

const std::string baseCpp = \
"#include \"TableName_model.h\" \n" \
"\n" \
"namespace ds {\n" \
"namespace model {\n" \
"namespace {\n" \
"const int							EMPTY_INT = 0;\n" \
"const unsigned int					EMPTY_UINT = 0;\n" \
"const float							EMPTY_FLOAT = 0.0f;\n" \
"const std::wstring					EMPTY_WSTRING;\n" \
"const ds::Resource					EMPTY_RESOURCE;\n" \
"}\n" \
"\n" \
"/**\n" \
"* \\class ds::model::Data\n" \
"*/\n" \
"class TableNameRef::Data {\n" \
"public:\n" \
"	Data(){}\n" \
"\n" \
"DATA_MEMBERS\n" \
"\n" \
"};\n" \
"\n" \
"TableNameRef::TableNameRef(){}\n" \
"\n" \
"\n" \
"IMP_GETTERS\n" \
"\n" \
"IMP_SETTERS\n" \
"\n" \
"\n" \
"} // namespace model\n" \
"} // namespace ds";

const std::string headerGetter = "	const DATA_TYPE getColumnName() const;";
const std::string headerSetter = "	TableNameRef& setColumnName(const DATA_TYPE& ColumnName);";
const std::string dataMember = "DATA_TYPE mColumnName;";
const std::string impGetter = "const DATA_TYPE TableNameRef::getColumnName() const {\n" \
"	if(!mData) return EMPTY_EMPTYDATATYPE; \n" \
"	return mData->mColumnName; \n" \
"}";
const std::string impSetter = "TableNameRef& TableNameRef::setColumnName(const DATA_TYPE& ColumnName){\n" \
"	if(!mData) mData.reset(new Data()); \n" \
"	if(mData) mData->mColumnName = ColumnName; \n" \
"	return *this; \n" \
"}";

const std::string intDataType = "int";
const std::string uintDataType = "unsigned int";
const std::string floatDataType = "float";
const std::string stringDataType = "std::wstring";
const std::string resourceDataType = "ds::Resource";
}

/**
* \class ds::ModelMaker
*/
ModelMaker::ModelMaker() {
	mYamlFileLocation = "";
}

std::string ModelMaker::replaceString(std::string& fullString, std::string toReplace, std::string replaceWith){
	return(fullString.replace(fullString.find(toReplace), toReplace.length(), replaceWith));
}

std::string ModelMaker::replaceAllString(std::string& fullString, std::string toReplace, std::string replaceWith){
	std::string returnString = fullString;
	while(returnString.find(toReplace) != std::string::npos)	{
		returnString = replaceString(returnString, toReplace, replaceWith);
	}

	return returnString;
}

void ModelMaker::run() {
	if(mYamlFileLocation.length() < 1){
		DS_LOG_WARNING("No file specified in model maker");
		return;
	}

	std::cout << "Parsing yaml file: " << mYamlFileLocation << std::endl;

	mYamlLoadService.mFileLocation = mYamlFileLocation;
	mYamlLoadService.run();

	std::vector<ModelModel> models = mYamlLoadService.mOutput;

	if(models.empty()){
		DS_LOG_WARNING("No valid models loaded in model maker.");
		return;
	}

	for(auto it = models.begin(); it < models.end(); ++it){
		ModelModel& mm = (*it);

		// make the first letter of the table name uppercase
		std::string tableName = mm.getTableName();
		std::transform(tableName.begin(), tableName.begin() + 1, tableName.begin(), ::toupper);

		// push all the nearby getters/setters/members into stringstreams
		std::stringstream sHeaderGetters;
		std::stringstream sHeaderSetters;
		std::stringstream sDataMembers;
		std::stringstream sImpGetters;
		std::stringstream sImpSetters;

		// strings for each column
		std::string thisHeaderGetter;
		std::string thisHeaderSetter;
		std::string thisEmptyData;
		std::string thisDataMember;
		std::string thisImpGetter;
		std::string thisImpSetter;

		// make all 'resource' flagged columns into proper resources
		for(auto mit = mm.getResourceColumns().begin(); mit < mm.getResourceColumns().end(); ++mit){
			for(auto cit = mm.getColumns().begin(); cit < mm.getColumns().end(); ++cit){

				// if this column is the resource one, set it's type to resource and move on
				if((*cit).getColumnName() == (*mit) && ((*cit).getType() == ModelColumn::Integer || (*cit).getType() == ModelColumn::UnsignedInt)) {
					ModelColumn* mc = const_cast<ModelColumn*>(&(*cit));
					if(mc){
						mc->setType(ModelColumn::Resource);
					}
					break;
				}
			}
		}


		// add the getters, setters, empty data and data members for each column to the stringstreams
		for(auto cit = mm.getColumns().begin(); cit < mm.getColumns().end(); ++cit){

			thisHeaderGetter = headerGetter;
			thisHeaderSetter = headerSetter;
			thisEmptyData = "";
			thisDataMember = dataMember;
			thisImpGetter = impGetter;
			thisImpSetter = impSetter;

			std::string dataType = "";

			const ModelColumn& mc = (*cit);

			// invalid columns get tossed
			if(mc.getType() == ModelColumn::Invalid){
				continue;

				// if it's an int, check for unsigned int too
			} else if(mc.getType() == ModelColumn::Integer || mc.getType() == ModelColumn::UnsignedInt){
				if(mc.getIsUnsigned()){
					dataType = uintDataType;
					thisEmptyData = "UINT";

				} else {
					dataType = intDataType;
					thisEmptyData = "INT";
				}

			} else if(mc.getType() == ModelColumn::Float){
				dataType = floatDataType;
				thisEmptyData = "FLOAT";

			} else if(mc.getType() == ModelColumn::String){
				dataType = stringDataType;
				thisEmptyData = "WSTRING";

			} else if(mc.getType() == ModelColumn::Resource){
				dataType = resourceDataType;
				thisEmptyData = "RESOURCE";

			}


			std::string columnName = mc.getColumnName();
			std::transform(columnName.begin(), columnName.begin() + 1, columnName.begin(), ::toupper);

			thisImpGetter = replaceAllString(thisImpGetter, "EMPTYDATATYPE", thisEmptyData);

			thisHeaderGetter = replaceAllString(thisHeaderGetter, "DATA_TYPE", dataType);
			thisHeaderSetter = replaceAllString(thisHeaderSetter, "DATA_TYPE", dataType); 	
			thisDataMember = replaceAllString(thisDataMember, "DATA_TYPE", dataType);
			thisImpGetter = replaceAllString(thisImpGetter, "DATA_TYPE", dataType);
			thisImpSetter = replaceAllString(thisImpSetter, "DATA_TYPE", dataType);

			sHeaderGetters << replaceAllString(thisHeaderGetter, "ColumnName", columnName) << std::endl;
			sHeaderSetters << replaceAllString(thisHeaderSetter, "ColumnName", columnName) << std::endl;
			sDataMembers << replaceAllString(thisDataMember, "ColumnName", columnName) << std::endl;
			sImpGetters << replaceAllString(thisImpGetter, "ColumnName", columnName) << std::endl;
			sImpSetters << replaceAllString(thisImpSetter, "ColumnName", columnName) << std::endl;

		}

		// add all the stringstreams to the header and put in the table name / model name
		std::string header = baseHeader;
		header = replaceAllString(header, "COLUMN_GETTERS", sHeaderGetters.str());
		header = replaceAllString(header, "COLUMN_SETTERS", sHeaderSetters.str());
		header = replaceAllString(header, "TableName", tableName);

		//std::cout << std::endl << std::endl << header << std::endl << std::endl;




		std::string imp = baseCpp;
		imp = replaceAllString(imp, "DATA_MEMBERS", sDataMembers.str());
		imp = replaceAllString(imp, "IMP_GETTERS", sImpGetters.str());
		imp = replaceAllString(imp, "IMP_SETTERS", sImpSetters.str());
		imp = replaceAllString(imp, "TableName", tableName);

		//	std::cout << std::endl << std::endl << imp << std::endl << std::endl;

		// make the filename a lowercase title
		std::string lower_case_table = mm.getTableName();
		std::transform(lower_case_table.begin(), lower_case_table.end(), lower_case_table.begin(), ::tolower);

		// write out the header and implementation
		std::stringstream filename;
		filename << "%APP%/generated/" << lower_case_table << "_model.h";

		std::cout << "Writing header to: " << filename.str() << std::endl;

		std::ofstream headerWriter;
		headerWriter.open(ds::Environment::expand(filename.str()));
		headerWriter << header;
		headerWriter.close();

		filename.str("");

		filename << "%APP%/generated/" << lower_case_table << "_model.cpp";
		std::cout << "Writing implementation to: " << filename.str() << std::endl;


		std::ofstream impWriter;
		impWriter.open(ds::Environment::expand(filename.str()));
		impWriter << imp;
		impWriter.close();
	}
}


} // namespace ds
